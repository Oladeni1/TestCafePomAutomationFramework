"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSkipJsErrorsOptions = exports.validateSkipJsErrorsOptionsObject = void 0;
const base_1 = __importDefault(require("./base"));
const skip_js_errors_option_names_1 = __importDefault(require("../../configuration/skip-js-errors-option-names"));
const types_1 = require("../../errors/types");
const runtime_1 = require("../../errors/runtime");
function _isSkipJsOption(option) {
    return Object.values(skip_js_errors_option_names_1.default).includes(option);
}
function validateSkipJsErrorsOptionsObject(options, ErrorCtor) {
    for (const key in options) {
        if (!_isSkipJsOption(key))
            throw new ErrorCtor(types_1.RUNTIME_ERRORS.invalidSkipJsErrorsOption, key);
    }
}
exports.validateSkipJsErrorsOptionsObject = validateSkipJsErrorsOptionsObject;
async function getSkipJsErrorsOptions(optionName, options) {
    if (typeof options === 'boolean')
        return options;
    const parsedOptions = await (0, base_1.default)(options, {
        async onOptionParsed(key, value) {
            if (!key || !value)
                throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue, optionName);
            return value;
        },
    });
    validateSkipJsErrorsOptionsObject(parsedOptions, runtime_1.GeneralError);
    return parsedOptions;
}
exports.getSkipJsErrorsOptions = getSkipJsErrorsOptions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2tpcC1qcy1lcnJvcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZ2V0LW9wdGlvbnMvc2tpcC1qcy1lcnJvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsa0RBQW9DO0FBQ3BDLGtIQUEwRjtBQUMxRiw4Q0FBb0Q7QUFDcEQsa0RBQW9EO0FBR3BELFNBQVMsZUFBZSxDQUFFLE1BQWM7SUFDcEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLHFDQUEyQixDQUFDLENBQUMsUUFBUSxDQUFDLE1BQXFDLENBQUMsQ0FBQztBQUN0RyxDQUFDO0FBRUQsU0FBZ0IsaUNBQWlDLENBQUUsT0FBd0QsRUFBRSxTQUFjO0lBQ3ZILEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDO1lBQ3JCLE1BQU0sSUFBSSxTQUFTLENBQUMsc0JBQWMsQ0FBQyx5QkFBeUIsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUMxRTtBQUNMLENBQUM7QUFMRCw4RUFLQztBQUVNLEtBQUssVUFBVSxzQkFBc0IsQ0FBRSxVQUFrQixFQUFFLE9BQXVEO0lBQ3JILElBQUksT0FBTyxPQUFPLEtBQUssU0FBUztRQUM1QixPQUFPLE9BQU8sQ0FBQztJQUVuQixNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUEsY0FBYyxFQUFDLE9BQTZCLEVBQUU7UUFDdEUsS0FBSyxDQUFDLGNBQWMsQ0FBRSxHQUFXLEVBQUUsS0FBc0I7WUFDckQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUs7Z0JBQ2QsTUFBTSxJQUFJLHNCQUFZLENBQUMsc0JBQWMsQ0FBQyw2QkFBNkIsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUVyRixPQUFPLEtBQUssQ0FBQztRQUNqQixDQUFDO0tBQ0osQ0FBQyxDQUFDO0lBRUgsaUNBQWlDLENBQUMsYUFBYSxFQUFFLHNCQUFZLENBQUMsQ0FBQztJQUUvRCxPQUFPLGFBQWEsQ0FBQztBQUN6QixDQUFDO0FBaEJELHdEQWdCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiYXNlR2V0T3B0aW9ucyBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IFNLSVBfSlNfRVJST1JTX09QVElPTl9OQU1FUyBmcm9tICcuLi8uLi9jb25maWd1cmF0aW9uL3NraXAtanMtZXJyb3JzLW9wdGlvbi1uYW1lcyc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgeyBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vLi4vY29uZmlndXJhdGlvbi9pbnRlcmZhY2VzJztcblxuZnVuY3Rpb24gX2lzU2tpcEpzT3B0aW9uIChvcHRpb246IHN0cmluZyk6IG9wdGlvbiBpcyBTS0lQX0pTX0VSUk9SU19PUFRJT05fTkFNRVMge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKFNLSVBfSlNfRVJST1JTX09QVElPTl9OQU1FUykuaW5jbHVkZXMob3B0aW9uIGFzIFNLSVBfSlNfRVJST1JTX09QVElPTl9OQU1FUyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNraXBKc0Vycm9yc09wdGlvbnNPYmplY3QgKG9wdGlvbnM6IERpY3Rpb25hcnk8dW5rbm93bj4gfCBTa2lwSnNFcnJvcnNPcHRpb25zT2JqZWN0LCBFcnJvckN0b3I6IGFueSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfaXNTa2lwSnNPcHRpb24oa2V5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckN0b3IoUlVOVElNRV9FUlJPUlMuaW52YWxpZFNraXBKc0Vycm9yc09wdGlvbiwga2V5KTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTa2lwSnNFcnJvcnNPcHRpb25zIChvcHRpb25OYW1lOiBzdHJpbmcsIG9wdGlvbnM6IHN0cmluZyB8IGJvb2xlYW4gfCBEaWN0aW9uYXJ5PHN0cmluZyB8IFJlZ0V4cD4pOiBQcm9taXNlPERpY3Rpb25hcnk8UmVnRXhwfHN0cmluZz4gfCBib29sZWFuPiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuXG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IGF3YWl0IGJhc2VHZXRPcHRpb25zKG9wdGlvbnMgYXMgRGljdGlvbmFyeTxzdHJpbmc+LCB7XG4gICAgICAgIGFzeW5jIG9uT3B0aW9uUGFyc2VkIChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IFJlZ0V4cCkge1xuICAgICAgICAgICAgaWYgKCFrZXkgfHwgIXZhbHVlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMub3B0aW9uVmFsdWVJc05vdFZhbGlkS2V5VmFsdWUsIG9wdGlvbk5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YWxpZGF0ZVNraXBKc0Vycm9yc09wdGlvbnNPYmplY3QocGFyc2VkT3B0aW9ucywgR2VuZXJhbEVycm9yKTtcblxuICAgIHJldHVybiBwYXJzZWRPcHRpb25zO1xufVxuIl19